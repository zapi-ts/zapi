// =============================================================================
// @ZAPI/GENERATOR
// Code generators for Prisma schema, TypeScript types, and API client
// =============================================================================

import { writeFileSync, mkdirSync, existsSync } from "fs"
import { join, dirname } from "path"
import type { Entity, FieldDef, FieldType } from "zapi"
import { pluralize, resolveEntity } from "zapi"

// -----------------------------------------------------------------------------
// Constants
// -----------------------------------------------------------------------------

const PRISMA_TYPES: Record<FieldType, string> = {
  string: "String",
  text: "String",
  int: "Int",
  float: "Float",
  boolean: "Boolean",
  datetime: "DateTime",
  json: "Json",
}

const TS_TYPES: Record<FieldType, string> = {
  string: "string",
  text: "string",
  int: "number",
  float: "number",
  boolean: "boolean",
  datetime: "Date",
  json: "unknown",
}

// -----------------------------------------------------------------------------
// Helpers
// -----------------------------------------------------------------------------

function pascalCase(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1)
}

function ensureDir(dir: string): void {
  if (!existsSync(dir)) {
    mkdirSync(dir, { recursive: true })
  }
}

function writeFile(path: string, content: string): void {
  ensureDir(dirname(path))
  writeFileSync(path, content, "utf-8")
}

// -----------------------------------------------------------------------------
// Prisma Schema Generator
// -----------------------------------------------------------------------------

export function generatePrismaSchema(
  entities: Entity[],
  options: { provider?: string } = {}
): string {
  const { provider = "sqlite" } = options

  let schema = `// =============================================================================
// GENERATED BY ZAPI - DO NOT EDIT MANUALLY
// Regenerate with: npx zapi generate
// =============================================================================

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "${provider}"
  url      = env("DATABASE_URL")
}
`

  // Build a map of all relations pointing to each entity for inverse relations
  const inverseRelations: Record<string, { fromEntity: string; fieldName: string; type: string }[]> = {}
  
  for (const entityDef of entities) {
    const entity = resolveEntity(entityDef)
    for (const [fieldName, field] of Object.entries(entity.config.fields)) {
      if (field.relation?.type === "belongsTo") {
        const relatedEntity = resolveEntity(field.relation.entity())
        if (!inverseRelations[relatedEntity.name]) {
          inverseRelations[relatedEntity.name] = []
        }
        inverseRelations[relatedEntity.name].push({
          fromEntity: entity.name,
          fieldName,
          type: "hasMany" // belongsTo creates a hasMany on the other side
        })
      }
    }
  }

  // Check for entities that have multiple relations to the same target
  const relationNames: Record<string, Record<string, string>> = {} // entityName -> fieldName -> relationName
  
  for (const entityDef of entities) {
    const entity = resolveEntity(entityDef)
    const targetCounts: Record<string, string[]> = {}
    
    for (const [fieldName, field] of Object.entries(entity.config.fields)) {
      if (field.relation?.type === "belongsTo") {
        const relatedEntity = resolveEntity(field.relation.entity())
        if (!targetCounts[relatedEntity.name]) {
          targetCounts[relatedEntity.name] = []
        }
        targetCounts[relatedEntity.name].push(fieldName)
      }
    }
    
    // If multiple relations to same entity, we need relation names
    for (const [target, fields] of Object.entries(targetCounts)) {
      if (fields.length > 1) {
        if (!relationNames[entity.name]) relationNames[entity.name] = {}
        for (const fieldName of fields) {
          relationNames[entity.name][fieldName] = fieldName
        }
      }
    }
  }

  for (const entityDef of entities) {
    const entity = resolveEntity(entityDef)
    const modelName = pascalCase(entity.name)

    schema += `\nmodel ${modelName} {\n`

    // ID field
    schema += `  id            String   @id @default(uuid())\n`

    // Regular fields
    for (const [fieldName, field] of Object.entries(entity.config.fields)) {
      // Skip hasMany relations (defined on other side)
      if (field.relation?.type === "hasMany") continue

      // Skip belongsTo (we'll add foreign key)
      if (field.relation?.type === "belongsTo") continue

      const prismaType = PRISMA_TYPES[field.type] || "String"
      let line = `  ${fieldName.padEnd(12)} ${prismaType}`

      if (field.optional) line += "?"
      
      // Add attributes
      const attrs: string[] = []
      if (field.unique) attrs.push("@unique")
      if (field.default !== undefined) {
        if (typeof field.default === "boolean") {
          attrs.push(`@default(${field.default})`)
        } else if (typeof field.default === "number") {
          attrs.push(`@default(${field.default})`)
        } else if (typeof field.default === "string") {
          attrs.push(`@default("${field.default}")`)
        }
      }

      if (attrs.length > 0) {
        line += " " + attrs.join(" ")
      }

      schema += line + "\n"
    }

    // Timestamps
    if (entity.config.timestamps) {
      schema += `  createdAt     DateTime @default(now())\n`
      schema += `  updatedAt     DateTime @updatedAt\n`
    }

    // Foreign keys and relations
    const foreignKeys: string[] = []

    for (const [fieldName, field] of Object.entries(entity.config.fields)) {
      if (!field.relation) continue

      // Resolve the related entity (might be Entity or EntityBuilder)
      const relatedEntityOrBuilder = field.relation.entity()
      const relatedEntity = resolveEntity(relatedEntityOrBuilder)
      const relatedModel = pascalCase(relatedEntity.name)

      if (field.relation.type === "belongsTo") {
        const fk = field.relation.foreignKey
        foreignKeys.push(fk)

        // Foreign key field
        schema += `  ${fk.padEnd(12)} String${field.optional ? "?" : ""}\n`

        // Relation - add name if multiple relations to same entity
        const relName = relationNames[entity.name]?.[fieldName]
        const nameAttr = relName ? `"${relName}", ` : ""
        const onDelete = field.relation.onDelete
          ? `, onDelete: ${pascalCase(field.relation.onDelete)}`
          : ""
        schema += `  ${fieldName.padEnd(12)} ${relatedModel}? @relation(${nameAttr}fields: [${fk}], references: [id]${onDelete})\n`
      } else if (field.relation.type === "hasMany") {
        schema += `  ${fieldName.padEnd(12)} ${relatedModel}[]\n`
      } else if (field.relation.type === "hasOne") {
        schema += `  ${fieldName.padEnd(12)} ${relatedModel}?\n`
      }
    }

    // Add inverse relations (hasMany back-references)
    const inverses = inverseRelations[entity.name] || []
    for (const inv of inverses) {
      const fromModel = pascalCase(inv.fromEntity)
      const fieldName = `${inv.fromEntity}s_${inv.fieldName}` // e.g. "tasks_assignee"
      
      // Check if this relation needs a name (because source has multiple relations to this entity)
      const relName = relationNames[inv.fromEntity]?.[inv.fieldName]
      const nameAttr = relName ? `@relation("${relName}")` : ""
      
      schema += `  ${fieldName.padEnd(12)} ${fromModel}[] ${nameAttr}\n`
    }

    // Indexes for foreign keys
    if (foreignKeys.length > 0) {
      schema += "\n"
      for (const fk of foreignKeys) {
        schema += `  @@index([${fk}])\n`
      }
    }

    schema += "}\n"
  }

  return schema
}

// -----------------------------------------------------------------------------
// TypeScript Types Generator
// -----------------------------------------------------------------------------

export function generateTypes(entities: Entity[]): string {
  let output = `// =============================================================================
// GENERATED BY ZAPI - DO NOT EDIT MANUALLY
// Regenerate with: npx zapi generate
// =============================================================================

`

  for (const entityDef of entities) {
    const entity = resolveEntity(entityDef)
    const typeName = pascalCase(entity.name)

    // Main interface
    output += `export interface ${typeName} {\n`
    output += `  id: string\n`

    for (const [fieldName, field] of Object.entries(entity.config.fields)) {
      if (field.relation?.type === "hasMany") continue
      if (field.relation?.type === "belongsTo") {
        // Add foreign key
        const fk = field.relation.foreignKey
        output += `  ${fk}${field.optional ? "?" : ""}: string\n`
        continue
      }

      const tsType = TS_TYPES[field.type] || "unknown"
      output += `  ${fieldName}${field.optional ? "?" : ""}: ${tsType}\n`
    }

    if (entity.config.timestamps) {
      output += `  createdAt: Date\n`
      output += `  updatedAt: Date\n`
    }

    output += `}\n\n`

    // Create input
    output += `export interface ${typeName}Create {\n`

    for (const [fieldName, field] of Object.entries(entity.config.fields)) {
      if (field.relation?.type === "hasMany") continue
      if (field.relation?.type === "belongsTo") {
        const fk = field.relation.foreignKey
        // Skip owner field (auto-set)
        if (entity.config.ownerField === fk) continue
        output += `  ${fk}${field.optional ? "?" : ""}: string\n`
        continue
      }

      const tsType = TS_TYPES[field.type] || "unknown"
      const optional = field.optional || field.default !== undefined
      output += `  ${fieldName}${optional ? "?" : ""}: ${tsType}\n`
    }

    output += `}\n\n`

    // Update input
    output += `export interface ${typeName}Update {\n`

    for (const [fieldName, field] of Object.entries(entity.config.fields)) {
      if (field.relation?.type === "hasMany") continue
      if (field.relation?.type === "belongsTo") {
        const fk = field.relation.foreignKey
        if (entity.config.ownerField === fk) continue
        output += `  ${fk}?: string\n`
        continue
      }

      const tsType = TS_TYPES[field.type] || "unknown"
      output += `  ${fieldName}?: ${tsType}\n`
    }

    output += `}\n\n`
  }

  return output
}

// -----------------------------------------------------------------------------
// API Client Generator
// -----------------------------------------------------------------------------

export function generateClient(entities: Entity[]): string {
  const imports = entities.map(e => {
    const entity = resolveEntity(e)
    const name = pascalCase(entity.name)
    return `  ${name},\n  ${name}Create,\n  ${name}Update,`
  }).join("\n")

  let output = `// =============================================================================
// GENERATED BY ZAPI - DO NOT EDIT MANUALLY
// Regenerate with: npx zapi generate
// =============================================================================

import type {
${imports}
} from "./types"

// -----------------------------------------------------------------------------
// Configuration
// -----------------------------------------------------------------------------

export interface ClientConfig {
  baseUrl: string
  headers?: Record<string, string>
  onError?: (error: ApiError) => void
}

// -----------------------------------------------------------------------------
// Types
// -----------------------------------------------------------------------------

export interface ListResponse<T> {
  data: T[]
  pagination: {
    total: number
    limit: number
    offset: number
  }
}

export interface ApiError {
  code: string
  message: string
  details?: { field: string; message: string }[]
}

export interface ListOptions {
  filter?: Record<string, string | number | boolean>
  sort?: string
  limit?: number
  offset?: number
  include?: string
}

// -----------------------------------------------------------------------------
// HTTP Client
// -----------------------------------------------------------------------------

async function request<T>(
  config: ClientConfig,
  method: string,
  path: string,
  body?: unknown
): Promise<T> {
  const { baseUrl, headers = {} } = config

  const res = await fetch(\`\${baseUrl}\${path}\`, {
    method,
    headers: {
      "Content-Type": "application/json",
      ...headers,
    },
    body: body ? JSON.stringify(body) : undefined,
    credentials: "include",
  })

  if (!res.ok) {
    const error = await res.json().catch(() => ({ message: res.statusText }))
    const err = error.error || error
    config.onError?.(err)
    throw err
  }

  if (res.status === 204) return null as T

  return res.json()
}

function buildQuery(options?: ListOptions): string {
  if (!options) return ""
  
  const params = new URLSearchParams()
  
  if (options.filter) {
    for (const [key, value] of Object.entries(options.filter)) {
      params.append(\`filter[\${key}]\`, String(value))
    }
  }
  
  if (options.sort) params.append("sort", options.sort)
  if (options.limit) params.append("limit", String(options.limit))
  if (options.offset) params.append("offset", String(options.offset))
  if (options.include) params.append("include", options.include)
  
  const query = params.toString()
  return query ? \`?\${query}\` : ""
}

// -----------------------------------------------------------------------------
// Client Factory
// -----------------------------------------------------------------------------

export function createClient(config: ClientConfig) {
  return {
`

  for (const entityDef of entities) {
    const entity = resolveEntity(entityDef)
    const name = entity.name
    const plural = pluralize(name)
    const typeName = pascalCase(name)

    output += `    ${plural}: {
      list: (options?: ListOptions) =>
        request<ListResponse<${typeName}>>(config, "GET", "/${plural}" + buildQuery(options)),

      get: (id: string, options?: { include?: string }) =>
        request<${typeName}>(config, "GET", \`/${plural}/\${id}\${options?.include ? \`?include=\${options.include}\` : ""}\`),

      create: (data: ${typeName}Create) =>
        request<${typeName}>(config, "POST", "/${plural}", data),

      update: (id: string, data: ${typeName}Update) =>
        request<${typeName}>(config, "PUT", \`/${plural}/\${id}\`, data),

      delete: (id: string) =>
        request<void>(config, "DELETE", \`/${plural}/\${id}\`),
    },

`
  }

  output += `  }
}

export default createClient
`

  return output
}

// -----------------------------------------------------------------------------
// Main Generate Function
// -----------------------------------------------------------------------------

export interface GenerateOptions {
  outDir?: string
  prismaProvider?: string
}

export interface GenerateResult {
  files: string[]
}

export function generate(
  entities: Entity[],
  options: GenerateOptions = {}
): GenerateResult {
  const { outDir = "./generated", prismaProvider = "sqlite" } = options

  const files: string[] = []

  // Resolve all entities
  const resolvedEntities = entities.map(resolveEntity)

  console.log("\nðŸ”§ zapi generate\n")
  console.log(`   Found ${resolvedEntities.length} entities:`)
  resolvedEntities.forEach(e => console.log(`   - ${e.name}`))
  console.log()

  // 1. Prisma schema
  const prismaPath = join(outDir, "prisma", "schema.prisma")
  writeFile(prismaPath, generatePrismaSchema(resolvedEntities, { provider: prismaProvider }))
  files.push(prismaPath)
  console.log(`   âœ… ${prismaPath}`)

  // 2. TypeScript types
  const typesPath = join(outDir, "types.ts")
  writeFile(typesPath, generateTypes(resolvedEntities))
  files.push(typesPath)
  console.log(`   âœ… ${typesPath}`)

  // 3. API client
  const clientPath = join(outDir, "client.ts")
  writeFile(clientPath, generateClient(resolvedEntities))
  files.push(clientPath)
  console.log(`   âœ… ${clientPath}`)

  console.log(`
   Next steps:
   1. Run: npx prisma db push --schema=${prismaPath}
   2. Run: npm run dev
`)

  return { files }
}
